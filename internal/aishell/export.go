package aishell

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// generateDockerfile returns the Dockerfile content for export.
// The exported Dockerfile uses COPY (not paths from the repo) since scripts
// will be in the same directory as the Dockerfile.
// Note: We avoid COPY --chmod since it requires BuildKit and may not work with Podman.
func generateDockerfile(baseImage string) string {
	return fmt.Sprintf(`ARG BASE_IMAGE=%s
FROM ${BASE_IMAGE}

WORKDIR /work

COPY setup-git-ssh.sh /docker/setup-git-ssh.sh
COPY bootstrap-tools.sh /docker/bootstrap-tools.sh
COPY bootstrap-tools.py /docker/bootstrap-tools.py
RUN chmod 0755 /docker/setup-git-ssh.sh /docker/bootstrap-tools.sh

# Note: cursor-agent CLI is installed by running the bootstrap tools
# This is because /root is mounted as a volume, which would overwrite the installation
# Installing it after container creation ensures it persists in the /root volume

# Keep container running without assuming tail/coreutils.
CMD ["sh", "-c", "while true; do sleep 3600; done"]
`, baseImage)
}

// generateComposeYAML returns the docker-compose.yml content for export.
func generateComposeYAML(workdir, iid, container, volume, cursorDir string) string {
	// Build the YAML manually to control formatting and comments.
	var sb strings.Builder

	sb.WriteString("# Generated by ai-shell eject\n")
	sb.WriteString("# Works with both docker compose and podman-compose\n")
	sb.WriteString("\n")
	sb.WriteString("services:\n")
	sb.WriteString("  ai-shell:\n")
	sb.WriteString("    build:\n")
	sb.WriteString("      context: .\n")
	sb.WriteString("    image: ai-agent-shell\n")
	sb.WriteString(fmt.Sprintf("    container_name: %s\n", container))
	sb.WriteString("    labels:\n")
	sb.WriteString(fmt.Sprintf("      %s: \"true\"\n", LabelManaged))
	sb.WriteString(fmt.Sprintf("      %s: \"1\"\n", LabelSchema))
	sb.WriteString(fmt.Sprintf("      %s: \"%s\"\n", LabelWorkdir, workdir))
	sb.WriteString(fmt.Sprintf("      %s: \"%s\"\n", LabelInstance, iid))
	sb.WriteString(fmt.Sprintf("      %s: \"%s\"\n", LabelVolume, volume))
	sb.WriteString("    volumes:\n")
	sb.WriteString("      - ..:/work                           # parent dir = workdir\n")
	sb.WriteString(fmt.Sprintf("      - %s:/root\n", volume))
	sb.WriteString(fmt.Sprintf("      - %s:/root/.config/cursor:ro\n", cursorDir))
	sb.WriteString("    env_file:\n")
	sb.WriteString("      - path: ${AI_SHELL_ENV_FILE:-/dev/null}\n")
	sb.WriteString("        required: false\n")
	sb.WriteString("    command: [\"sh\", \"-c\", \"while true; do sleep 3600; done\"]\n")
	sb.WriteString("\n")
	sb.WriteString("volumes:\n")
	sb.WriteString(fmt.Sprintf("  %s:\n", volume))
	sb.WriteString("    external: false\n")

	return sb.String()
}

// generateReadme returns the README.md content for the exported directory.
func generateReadme(container string) string {
	return fmt.Sprintf(`# ai-shell Ejected Configuration

This directory contains Docker Compose configuration exported by `+"`ai-shell eject`"+`.

## Usage

### Build and start the container

%s
docker compose up -d --build
%s

Or with podman-compose (install via `+"`pipx install podman-compose`"+`):

%s
podman-compose up -d --build
%s

### Enter the container

%s
docker compose exec ai-shell bash
# or: podman-compose exec ai-shell bash
%s

### Bootstrap tools (install common utilities)

%s
docker compose exec ai-shell /docker/bootstrap-tools.sh
%s

### Setup Git SSH access

%s
docker compose exec ai-shell /docker/setup-git-ssh.sh
%s

### Stop the container

%s
docker compose down
# or: podman-compose down
%s

## Notes

- The parent directory is mounted at `+"`/work`"+` inside the container
- The `+"`/root`"+` directory is persisted in a named volume
- Cursor config is mounted read-only from `+"`~/.config/cursor`"+`
- The `+"`ai-shell`"+` CLI commands (`+"`ai-shell status`"+`, `+"`ai-shell enter`"+`, etc.) will still work with this container since it uses the standard ai-shell labels
- Set `+"`AI_SHELL_ENV_FILE`"+` environment variable to inject secrets (e.g., `+"`GH_TOKEN`"+`)

## Customization

Edit `+"`docker-compose.yml`"+` to:
- Add additional volume mounts
- Change environment variables
- Modify the base image (edit the Dockerfile ARG)
- Add more services

Container name: `+"`%s`"+`
`, "```bash", "```", "```bash", "```", "```bash", "```", "```bash", "```", "```bash", "```", "```bash", "```", container)
}

// exportFiles writes all export files to the output directory.
func exportFiles(outputDir, workdir string, cfg *Config, baseImage, cursorDir string, force bool) error {
	// Resolve instance details
	containerBase, _, volumeBase := resolveBases(cfg)
	iid := InstanceID(workdir)
	container, volume := NamesFor(workdir, containerBase, volumeBase)

	// Create output directory
	if err := os.MkdirAll(outputDir, 0o755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Check for existing files if not forcing
	files := []string{"Dockerfile", "docker-compose.yml", "bootstrap-tools.sh", "bootstrap-tools.py", "setup-git-ssh.sh", "README.md"}
	if !force {
		var existing []string
		for _, f := range files {
			p := filepath.Join(outputDir, f)
			if _, err := os.Stat(p); err == nil {
				existing = append(existing, f)
			}
		}
		if len(existing) > 0 {
			return fmt.Errorf("files already exist in %s: %s\nUse --force to overwrite", outputDir, strings.Join(existing, ", "))
		}
	}

	// Find the source docker directory (for copying scripts)
	home, err := resolveHome(cfg)
	if err != nil {
		return fmt.Errorf("cannot locate source docker files: %w", err)
	}
	dockerDir, err := resolveDockerDir(home)
	if err != nil {
		return err
	}

	// Generate and write Dockerfile
	dockerfileContent := generateDockerfile(baseImage)
	if err := os.WriteFile(filepath.Join(outputDir, "Dockerfile"), []byte(dockerfileContent), 0o644); err != nil {
		return fmt.Errorf("failed to write Dockerfile: %w", err)
	}

	// Generate and write docker-compose.yml
	composeContent := generateComposeYAML(workdir, iid, container, volume, cursorDir)
	if err := os.WriteFile(filepath.Join(outputDir, "docker-compose.yml"), []byte(composeContent), 0o644); err != nil {
		return fmt.Errorf("failed to write docker-compose.yml: %w", err)
	}

	// Copy helper scripts from source
	scripts := []struct {
		name string
		perm os.FileMode
	}{
		{"bootstrap-tools.sh", 0o755},
		{"bootstrap-tools.py", 0o644},
		{"setup-git-ssh.sh", 0o755},
	}

	for _, s := range scripts {
		srcPath := filepath.Join(dockerDir, s.name)
		dstPath := filepath.Join(outputDir, s.name)

		content, err := os.ReadFile(srcPath)
		if err != nil {
			return fmt.Errorf("failed to read %s: %w", s.name, err)
		}

		if err := os.WriteFile(dstPath, content, s.perm); err != nil {
			return fmt.Errorf("failed to write %s: %w", s.name, err)
		}
	}

	// Generate and write README.md
	readmeContent := generateReadme(container)
	if err := os.WriteFile(filepath.Join(outputDir, "README.md"), []byte(readmeContent), 0o644); err != nil {
		return fmt.Errorf("failed to write README.md: %w", err)
	}

	return nil
}
