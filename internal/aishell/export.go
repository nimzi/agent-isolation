package aishell

import (
	_ "embed"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

//go:embed scripts/bootstrap-tools.sh
var bootstrapToolsSh string

//go:embed scripts/bootstrap-tools.py
var bootstrapToolsPy string

//go:embed scripts/setup-git-ssh.sh
var setupGitSshSh string

// generateDockerfile returns the Dockerfile content.
// Scripts are accessed via the mounted workdir at /work/.ai-shell/, so no COPY needed.
func generateDockerfile(baseImage string) string {
	return fmt.Sprintf(`ARG BASE_IMAGE=%s
FROM ${BASE_IMAGE}

WORKDIR /work

# Scripts are accessed from the mounted workdir at /work/.ai-shell/
# No need to COPY them into the image.

# Note: cursor-agent CLI is installed by running the bootstrap tools
# This is because /root is mounted as a volume, which would overwrite the installation
# Installing it after container creation ensures it persists in the /root volume

# Keep container running without assuming tail/coreutils.
CMD ["sh", "-c", "while true; do sleep 3600; done"]
`, baseImage)
}

// generateComposeYAML returns the docker-compose.yml content for export.
// The workdir is discovered dynamically from the /work bind mount, not stored as a label.
func generateComposeYAML(iid, container, volume, cursorDir string) string {
	// Build the YAML manually to control formatting and comments.
	var sb strings.Builder

	sb.WriteString("# Generated by ai-shell init\n")
	sb.WriteString("# Works with both docker compose and podman-compose\n")
	sb.WriteString("#\n")
	sb.WriteString("# Note: workdir is discovered from the /work bind mount (..:/work),\n")
	sb.WriteString("# so this file is portable across machines.\n")
	sb.WriteString("\n")
	sb.WriteString("services:\n")
	sb.WriteString("  ai-shell:\n")
	sb.WriteString("    build:\n")
	sb.WriteString("      context: .\n")
	sb.WriteString("      args:\n")
	sb.WriteString("        - BASE_IMAGE=${BASE_IMAGE:-ubuntu:24.04}\n")
	sb.WriteString("    image: ai-agent-shell\n")
	sb.WriteString(fmt.Sprintf("    container_name: %s\n", container))
	sb.WriteString("    labels:\n")
	sb.WriteString(fmt.Sprintf("      %s: \"true\"\n", LabelManaged))
	sb.WriteString(fmt.Sprintf("      %s: \"1\"\n", LabelSchema))
	sb.WriteString(fmt.Sprintf("      %s: \"%s\"\n", LabelInstance, iid))
	sb.WriteString(fmt.Sprintf("      %s: \"%s\"\n", LabelVolume, volume))
	sb.WriteString("    volumes:\n")
	sb.WriteString("      - ..:/work                           # parent dir = workdir (source of truth)\n")
	sb.WriteString(fmt.Sprintf("      - %s:/root\n", volume))
	sb.WriteString(fmt.Sprintf("      - %s:/root/.config/cursor:ro\n", cursorDir))
	sb.WriteString("    env_file:\n")
	sb.WriteString("      - path: ${AI_SHELL_ENV_FILE:-/dev/null}\n")
	sb.WriteString("        required: false\n")
	sb.WriteString("    command: [\"sh\", \"-c\", \"while true; do sleep 3600; done\"]\n")
	sb.WriteString("\n")
	sb.WriteString("volumes:\n")
	sb.WriteString(fmt.Sprintf("  %s:\n", volume))
	sb.WriteString("    external: false\n")

	return sb.String()
}

// generateReadme returns the README.md content for the .ai-shell directory.
func generateReadme(container string) string {
	return fmt.Sprintf(`# ai-shell Configuration

This directory contains the ai-shell configuration for this project.

## Usage

### Initialize and start (recommended)

%s
ai-shell up
%s

### Or use Docker Compose directly

%s
docker compose up -d --build
%s

Or with podman-compose (install via `+"`pipx install podman-compose`"+`):

%s
podman-compose up -d --build
%s

### Enter the container

%s
ai-shell enter
# or: docker compose exec ai-shell bash
%s

### Bootstrap tools (install common utilities)

%s
docker compose exec ai-shell sh /work/.ai-shell/bootstrap-tools.sh
%s

### Setup Git SSH access

%s
docker compose exec ai-shell sh /work/.ai-shell/setup-git-ssh.sh
%s

### Stop the container

%s
ai-shell stop
# or: docker compose down
%s

## Notes

- The parent directory (your project) is mounted at `+"`/work`"+` inside the container
- Scripts are accessed from `+"`/work/.ai-shell/`"+` (this directory, mounted)
- The `+"`/root`"+` directory is persisted in a named volume
- Cursor config is mounted read-only from `+"`~/.config/cursor`"+`
- The `+"`ai-shell`"+` CLI commands (`+"`ai-shell status`"+`, `+"`ai-shell enter`"+`, etc.) work with this container
- Set `+"`AI_SHELL_ENV_FILE`"+` environment variable to inject secrets (e.g., `+"`GH_TOKEN`"+`)

## Customization

You can customize this configuration for your project:

- `+"`Dockerfile`"+`: Change base image, add packages, etc.
- `+"`docker-compose.yml`"+`: Add volume mounts, environment variables, services
- `+"`bootstrap-tools.sh`"+`/`+"`bootstrap-tools.py`"+`: Modify which packages are installed
- `+"`setup-git-ssh.sh`"+`: Customize SSH/git setup

Container name: `+"`%s`"+`
`, "```bash", "```", "```bash", "```", "```bash", "```", "```bash", "```", "```bash", "```", "```bash", "```", "```bash", "```", container)
}

// exportFiles writes all export files to the output directory.
// Scripts are embedded in the binary and written to the output directory.
func exportFiles(outputDir, workdir string, cfg *Config, baseImage, cursorDir string, force bool) error {
	// Resolve instance details
	containerBase, _, volumeBase := resolveBases(cfg)
	iid := InstanceID(workdir)
	container, volume := NamesFor(workdir, containerBase, volumeBase)

	// Create output directory
	if err := os.MkdirAll(outputDir, 0o755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Check for existing files if not forcing
	files := []string{"Dockerfile", "docker-compose.yml", "bootstrap-tools.sh", "bootstrap-tools.py", "setup-git-ssh.sh", "README.md"}
	if !force {
		var existing []string
		for _, f := range files {
			p := filepath.Join(outputDir, f)
			if _, err := os.Stat(p); err == nil {
				existing = append(existing, f)
			}
		}
		if len(existing) > 0 {
			return fmt.Errorf("files already exist in %s: %s\nUse --force to overwrite", outputDir, strings.Join(existing, ", "))
		}
	}

	// Generate and write Dockerfile
	dockerfileContent := generateDockerfile(baseImage)
	if err := os.WriteFile(filepath.Join(outputDir, "Dockerfile"), []byte(dockerfileContent), 0o644); err != nil {
		return fmt.Errorf("failed to write Dockerfile: %w", err)
	}

	// Generate and write docker-compose.yml
	// Note: workdir is not passed; it's discovered from the /work bind mount.
	composeContent := generateComposeYAML(iid, container, volume, cursorDir)
	if err := os.WriteFile(filepath.Join(outputDir, "docker-compose.yml"), []byte(composeContent), 0o644); err != nil {
		return fmt.Errorf("failed to write docker-compose.yml: %w", err)
	}

	// Write embedded helper scripts
	scripts := []struct {
		name    string
		content string
		perm    os.FileMode
	}{
		{"bootstrap-tools.sh", bootstrapToolsSh, 0o755},
		{"bootstrap-tools.py", bootstrapToolsPy, 0o644},
		{"setup-git-ssh.sh", setupGitSshSh, 0o755},
	}

	for _, s := range scripts {
		dstPath := filepath.Join(outputDir, s.name)
		if err := os.WriteFile(dstPath, []byte(s.content), s.perm); err != nil {
			return fmt.Errorf("failed to write %s: %w", s.name, err)
		}
	}

	// Generate and write README.md
	readmeContent := generateReadme(container)
	if err := os.WriteFile(filepath.Join(outputDir, "README.md"), []byte(readmeContent), 0o644); err != nil {
		return fmt.Errorf("failed to write README.md: %w", err)
	}

	return nil
}
