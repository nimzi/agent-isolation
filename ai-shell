#!/usr/bin/env python3
"""
ai-shell: manage the ai-agent-shell container used for AI agent CLIs (e.g. cursor-agent).
"""

from __future__ import annotations

import argparse
import os
import subprocess
import sys
from pathlib import Path
from typing import Iterable


DEFAULT_CONTAINER = "ai-agent-shell"
DEFAULT_IMAGE = "ai-agent-shell"
DEFAULT_VOLUME = "ai_agent_shell_home"


def eprint(*args: object) -> None:
    print(*args, file=sys.stderr)


def is_tty() -> bool:
    return sys.stdin.isatty() and sys.stdout.isatty()


def run(cmd: list[str], *, check: bool = True, capture: bool = False, text: bool = True, timeout: int | None = None) -> subprocess.CompletedProcess[str]:
    if capture:
        return subprocess.run(cmd, check=check, text=text, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, timeout=timeout)
    return subprocess.run(cmd, check=check, text=text, timeout=timeout)


def docker(args: list[str], *, check: bool = True, capture: bool = False, timeout: int | None = None) -> subprocess.CompletedProcess[str]:
    return run(["docker", *args], check=check, capture=capture, timeout=timeout)


def require_docker() -> None:
    try:
        docker(["version"], check=True, capture=True, timeout=20)
    except Exception as ex:  # noqa: BLE001 - small CLI
        raise SystemExit(f"Docker is not available: {ex}") from ex


def resolve_defaults(ns: argparse.Namespace) -> tuple[str, str, str]:
    container = ns.container or os.environ.get("AI_SHELL_CONTAINER") or DEFAULT_CONTAINER
    image = ns.image or os.environ.get("AI_SHELL_IMAGE") or DEFAULT_IMAGE
    volume = ns.volume or os.environ.get("AI_SHELL_VOLUME") or DEFAULT_VOLUME
    return container, image, volume


def resolve_env_file(ns: argparse.Namespace) -> list[str]:
    # If explicitly set, respect it. If absent, use .env only if it exists.
    if ns.env_file is not None:
        if ns.env_file == "":
            return []
        p = Path(ns.env_file)
        if not p.exists():
            raise SystemExit(f"Env file not found: {p}")
        return ["--env-file", str(p)]

    default = Path(".env")
    return ["--env-file", str(default)] if default.exists() else []


def container_exists(name: str) -> bool:
    # docker inspect returns non-zero if not found
    p = docker(["inspect", name], check=False, capture=True)
    return p.returncode == 0


def container_running(name: str) -> bool:
    p = docker(["inspect", "-f", "{{.State.Running}}", name], check=False, capture=True)
    return p.returncode == 0 and "true" in (p.stdout or "").strip().lower()


def ensure_host_cursor_config_dir(path: Path) -> None:
    if path.exists():
        return
    path.mkdir(parents=True, exist_ok=True)
    eprint(f"Note: created host Cursor config dir: {path}")
    eprint("      You still need to install/sign in to Cursor on the host.")


def cmd_recreate(ns: argparse.Namespace) -> int:
    require_docker()
    container, image, volume = resolve_defaults(ns)

    workdir = Path(ns.workdir).resolve() if ns.workdir else Path.cwd().resolve()
    if not workdir.exists():
        raise SystemExit(f"Workdir does not exist: {workdir}")

    cursor_config = Path(ns.cursor_config).expanduser().resolve()
    ensure_host_cursor_config_dir(cursor_config)

    # Stop/remove existing container
    docker(["stop", container], check=False)
    docker(["rm", container], check=False)

    # Build image
    docker(["build", "-t", image, "."])

    # Create and start container
    env_args = resolve_env_file(ns)
    docker(
        [
            "run",
            "-d",
            "--name",
            container,
            "-v",
            f"{workdir}:/work",
            "-v",
            f"{volume}:/root",
            "-v",
            f"{cursor_config}:/root/.config/cursor",
            *env_args,
            image,
        ]
    )

    # Install cursor-agent into the /root volume if missing
    # (Install output suppressed to keep logs clean; use `ai-shell check` to verify.)
    p = docker(["exec", container, "bash", "-lc", "command -v cursor-agent >/dev/null 2>&1"], check=False)
    if p.returncode != 0:
        docker(["exec", container, "bash", "-lc", "curl https://cursor.com/install -fsSL | bash"], check=True)
        docker(["exec", container, "bash", "-lc", r'echo "export PATH=\"$HOME/.local/bin:$PATH\"" >> ~/.bashrc'], check=False)

    print(f"OK: container '{container}' is running.")
    print("Next:")
    print("  ./ai-shell enter")
    print("  ./ai-shell check")
    return 0


def cmd_start(ns: argparse.Namespace) -> int:
    require_docker()
    container, _, _ = resolve_defaults(ns)
    if not container_exists(container):
        raise SystemExit(f"Container not found: {container} (run: ./ai-shell recreate)")
    if container_running(container):
        print(f"OK: '{container}' already running.")
        return 0
    docker(["start", container])
    print(f"OK: started '{container}'.")
    return 0


def cmd_stop(ns: argparse.Namespace) -> int:
    require_docker()
    container, _, _ = resolve_defaults(ns)
    if not container_exists(container):
        raise SystemExit(f"Container not found: {container}")
    if not container_running(container):
        print(f"OK: '{container}' already stopped.")
        return 0
    docker(["stop", container])
    print(f"OK: stopped '{container}'.")
    return 0


def cmd_status(ns: argparse.Namespace) -> int:
    require_docker()
    container, image, volume = resolve_defaults(ns)
    exists = container_exists(container)
    running = container_running(container) if exists else False
    print(f"container: {container} ({'running' if running else 'stopped' if exists else 'missing'})")
    print(f"image:     {image}")
    print(f"volume:    {volume} -> /root")
    if not exists:
        return 0

    mounts = docker(["inspect", "-f", "{{range .Mounts}}{{println .Type .Source \"->\" .Destination}}{{end}}", container], capture=True).stdout or ""
    mounts = mounts.strip()
    if mounts:
        print("mounts:")
        for line in mounts.splitlines():
            print(f"  {line}")
    return 0


def cmd_enter(ns: argparse.Namespace) -> int:
    require_docker()
    container, _, _ = resolve_defaults(ns)
    if not container_exists(container):
        raise SystemExit(f"Container not found: {container} (run: ./ai-shell recreate)")
    if not container_running(container):
        docker(["start", container])

    # Ensure ~/.local/bin is on PATH for login shells
    docker(
        [
            "exec",
            container,
            "bash",
            "-lc",
            r'grep -q "\.local/bin" ~/.bashrc 2>/dev/null || echo "export PATH=\"$HOME/.local/bin:$PATH\"" >> ~/.bashrc',
        ],
        check=False,
    )

    if is_tty():
        os.execvp("docker", ["docker", "exec", "-it", container, "bash", "-l"])
    else:
        eprint("Warning: no TTY available; running non-interactive shell.")
        os.execvp("docker", ["docker", "exec", container, "bash", "-l"])


def redact_lines(lines: Iterable[str]) -> list[str]:
    redacted: list[str] = []
    for ln in lines:
        if "TOKEN=" in ln or "KEY=" in ln:
            k = ln.split("=", 1)[0]
            redacted.append(f"{k}=***")
        else:
            redacted.append(ln)
    return redacted


def cmd_check(ns: argparse.Namespace) -> int:
    require_docker()
    container, _, _ = resolve_defaults(ns)
    if not container_running(container):
        raise SystemExit(f"Container is not running: {container} (run: ./ai-shell start)")

    # 1) cursor-agent installed?
    p = docker(["exec", container, "bash", "-lc", "command -v cursor-agent && cursor-agent --help | head -30"], check=False, capture=True)
    if p.returncode != 0:
        eprint("ERROR: cursor-agent not found. Re-run: ./ai-shell recreate")
        if p.stdout:
            eprint(p.stdout.rstrip())
        return 2
    print("OK: cursor-agent is installed.")

    # 2) cursor config mount present?
    p2 = docker(["exec", container, "bash", "-lc", "ls -la /root/.config/cursor/ 2>/dev/null | head -50"], check=False, capture=True)
    if p2.returncode != 0:
        eprint("ERROR: /root/.config/cursor is missing. Ensure host Cursor is installed/signed in.")
        return 2
    print("OK: /root/.config/cursor is mounted.")

    # 3) gh auth (optional) - never fail the check
    p3 = docker(["exec", container, "bash", "-lc", "gh auth status 2>&1 | head -50"], check=False, capture=True)
    out = (p3.stdout or "").splitlines()
    out = redact_lines(out)
    if out:
        print("gh auth (optional):")
        for ln in out:
            print(f"  {ln}")
    else:
        print("gh auth (optional): (no output)")

    return 0


def build_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(
        prog="ai-shell",
        formatter_class=argparse.RawTextHelpFormatter,
        description=(
            "Manage the ai-agent-shell Docker container.\n\n"
            "Defaults can be overridden via env vars:\n"
            "  AI_SHELL_CONTAINER (default: ai-agent-shell)\n"
            "  AI_SHELL_IMAGE     (default: ai-agent-shell)\n"
            "  AI_SHELL_VOLUME    (default: ai_agent_shell_home)\n"
        ),
    )

    p.add_argument("--container", help="Container name (overrides AI_SHELL_CONTAINER)")
    p.add_argument("--image", help="Image name (overrides AI_SHELL_IMAGE)")
    p.add_argument("--volume", help="Volume name for /root (overrides AI_SHELL_VOLUME)")

    sub = p.add_subparsers(dest="cmd", required=True)

    sp = sub.add_parser("recreate", help="Build image, (re)create container, install cursor-agent")
    sp.add_argument("--workdir", help="Host directory to mount at /work (default: current directory)")
    sp.add_argument("--cursor-config", default="~/.config/cursor", help="Host Cursor config directory (default: ~/.config/cursor)")
    sp.add_argument(
        "--env-file",
        default=None,
        help=(
            "Env file to pass to docker run.\n"
            "Default: use ./.env only if it exists.\n"
            "Set to empty string to disable even if .env exists."
        ),
    )
    sp.set_defaults(func=cmd_recreate)

    sp = sub.add_parser("start", help="Start the container")
    sp.set_defaults(func=cmd_start)

    sp = sub.add_parser("stop", help="Stop the container")
    sp.set_defaults(func=cmd_stop)

    sp = sub.add_parser("status", help="Show container status and mounts")
    sp.set_defaults(func=cmd_status)

    sp = sub.add_parser("enter", help="Enter an interactive shell inside the container")
    sp.set_defaults(func=cmd_enter)

    sp = sub.add_parser("check", help="Sanity-check cursor-agent + mounts (and optional gh auth)")
    sp.set_defaults(func=cmd_check)

    return p


def main(argv: list[str]) -> int:
    parser = build_parser()
    ns = parser.parse_args(argv)

    # Ensure cwd is repo root for build contexts unless user deliberately runs elsewhere.
    # If invoked from elsewhere, Docker build/run paths would surprise; fail fast.
    if (Path.cwd() / "Dockerfile").exists() is False:
        raise SystemExit("Run this from the repo root (where Dockerfile exists).")

    return int(ns.func(ns))


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
