#!/usr/bin/env python3
"""
ai-shell: manage per-workdir Docker containers for AI agent CLIs (e.g. cursor-agent).
"""

from __future__ import annotations

import argparse
import hashlib
import json
import os
import subprocess
import sys
from pathlib import Path
from typing import Iterable


DEFAULT_CONTAINER_BASE = "ai-agent-shell"
DEFAULT_IMAGE = "ai-agent-shell"
DEFAULT_VOLUME_BASE = "ai_agent_shell_home"

LABEL_NS = "com.nimzi.ai-shell"
LABEL_MANAGED = f"{LABEL_NS}.managed"
LABEL_SCHEMA = f"{LABEL_NS}.schema"
LABEL_WORKDIR = f"{LABEL_NS}.workdir"
LABEL_INSTANCE = f"{LABEL_NS}.instance"
LABEL_VOLUME = f"{LABEL_NS}.volume"


def eprint(*args: object) -> None:
    print(*args, file=sys.stderr)


def is_tty() -> bool:
    return sys.stdin.isatty() and sys.stdout.isatty()


def run(cmd: list[str], *, check: bool = True, capture: bool = False, text: bool = True, timeout: int | None = None) -> subprocess.CompletedProcess[str]:
    if capture:
        return subprocess.run(cmd, check=check, text=text, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, timeout=timeout)
    return subprocess.run(cmd, check=check, text=text, timeout=timeout)


def docker(args: list[str], *, check: bool = True, capture: bool = False, timeout: int | None = None) -> subprocess.CompletedProcess[str]:
    return run(["docker", *args], check=check, capture=capture, timeout=timeout)


def require_docker() -> None:
    try:
        docker(["version"], check=True, capture=True, timeout=20)
    except Exception as ex:  # noqa: BLE001 - small CLI
        raise SystemExit(f"Docker is not available: {ex}") from ex


def resolve_bases(ns: argparse.Namespace) -> tuple[str, str, str]:
    container_base = ns.container_base or os.environ.get("AI_SHELL_CONTAINER") or DEFAULT_CONTAINER_BASE
    image = ns.image or os.environ.get("AI_SHELL_IMAGE") or DEFAULT_IMAGE
    volume_base = ns.volume_base or os.environ.get("AI_SHELL_VOLUME") or DEFAULT_VOLUME_BASE
    return container_base, image, volume_base


def canonical_workdir(p: str | None) -> str:
    wd = Path(p).expanduser() if p else Path.cwd()
    # resolve() canonicalizes and will error if parent doesn't exist when strict=True
    wd = wd.resolve(strict=True)
    if not wd.is_dir():
        raise SystemExit(f"Workdir is not a directory: {wd}")
    return str(wd)


def instance_id_for_workdir(workdir: str) -> str:
    # 10 hex chars = 40 bits. Low collision risk for normal usage; labels provide the ground truth.
    return hashlib.sha256(workdir.encode("utf-8")).hexdigest()[:10]


def instance_from_workdir(ns: argparse.Namespace, workdir: str | None) -> tuple[str, str, str, str, str]:
    """
    Returns (workdir, instance_id, container_name, image, volume_name).
    """
    wd = canonical_workdir(workdir)
    iid = instance_id_for_workdir(wd)
    container_base, image, volume_base = resolve_bases(ns)
    container_name = f"{container_base}-{iid}"
    volume_name = f"{volume_base}_{iid}"
    return wd, iid, container_name, image, volume_name


def resolve_env_file(ns: argparse.Namespace) -> list[str]:
    # If explicitly set, respect it. If absent, use .env only if it exists.
    if ns.env_file is not None:
        if ns.env_file == "":
            return []
        p = Path(ns.env_file)
        if not p.exists():
            raise SystemExit(f"Env file not found: {p}")
        return ["--env-file", str(p)]

    default = Path(".env")
    return ["--env-file", str(default)] if default.exists() else []


def container_exists(name: str) -> bool:
    # docker inspect returns non-zero if not found
    p = docker(["inspect", name], check=False, capture=True)
    return p.returncode == 0


def container_running(name: str) -> bool:
    p = docker(["inspect", "-f", "{{.State.Running}}", name], check=False, capture=True)
    return p.returncode == 0 and "true" in (p.stdout or "").strip().lower()


def inspect_container(name: str) -> dict:
    p = docker(["inspect", name], check=False, capture=True)
    if p.returncode != 0:
        raise SystemExit(f"Failed to inspect container: {name}")
    try:
        data = json.loads(p.stdout or "[]")
        if not data:
            raise ValueError("empty inspect output")
        return data[0]
    except Exception as ex:  # noqa: BLE001 - CLI
        raise SystemExit(f"Failed to parse docker inspect output for {name}: {ex}") from ex


def ensure_host_cursor_config_dir(path: Path) -> None:
    if path.exists():
        return
    path.mkdir(parents=True, exist_ok=True)
    eprint(f"Note: created host Cursor config dir: {path}")
    eprint("      You still need to install/sign in to Cursor on the host.")


def require_managed_container(container: str, expected_workdir: str | None = None) -> None:
    if not container_exists(container):
        raise SystemExit(f"Container not found: {container}")
    info = inspect_container(container)
    labels = ((info.get("Config") or {}).get("Labels") or {})
    managed = labels.get(LABEL_MANAGED)
    wd = labels.get(LABEL_WORKDIR, "")
    if managed != "true":
        raise SystemExit(f"Refusing: container '{container}' is not managed by ai-shell (missing label {LABEL_MANAGED}=true)")
    if expected_workdir is not None and wd != expected_workdir:
        raise SystemExit(f"Refusing: container '{container}' workdir label mismatch.\nExpected: {expected_workdir}\nFound:    {wd}")


def build_labels(workdir: str, instance_id: str, volume_name: str) -> list[str]:
    return [
        "--label",
        f"{LABEL_MANAGED}=true",
        "--label",
        f"{LABEL_SCHEMA}=1",
        "--label",
        f"{LABEL_WORKDIR}={workdir}",
        "--label",
        f"{LABEL_INSTANCE}={instance_id}",
        "--label",
        f"{LABEL_VOLUME}={volume_name}",
    ]


def install_cursor_agent_if_missing(container: str) -> None:
    p = docker(["exec", container, "bash", "-lc", "command -v cursor-agent >/dev/null 2>&1"], check=False)
    if p.returncode == 0:
        return
    docker(["exec", container, "bash", "-lc", "curl https://cursor.com/install -fsSL | bash"], check=True)
    docker(["exec", container, "bash", "-lc", r'echo "export PATH=\"$HOME/.local/bin:$PATH\"" >> ~/.bashrc'], check=False)


def cmd_up(ns: argparse.Namespace) -> int:
    require_docker()
    workdir, iid, container, image, volume = instance_from_workdir(ns, ns.workdir)

    cursor_config = Path(ns.cursor_config).expanduser().resolve(strict=False)
    ensure_host_cursor_config_dir(cursor_config)

    env_args = resolve_env_file(ns)

    if ns.recreate and container_exists(container):
        docker(["stop", container], check=False)
        docker(["rm", container], check=False)

    # Build image (safe + simple; Docker will cache layers)
    if ns.build:
        docker(["build", "-t", image, "."])

    if not container_exists(container):
        label_args = build_labels(workdir, iid, volume)
        docker(
            [
                "run",
                "-d",
                "--name",
                container,
                *label_args,
                "-v",
                f"{workdir}:/work",
                "-v",
                f"{volume}:/root",
                "-v",
                f"{cursor_config}:/root/.config/cursor",
                *env_args,
                image,
            ],
            capture=True,
        )
    else:
        require_managed_container(container, expected_workdir=workdir)
        if not container_running(container):
            docker(["start", container], capture=True)

    if ns.install:
        install_cursor_agent_if_missing(container)

    print(f"OK: up: {container}")
    print(f"workdir: {workdir}")
    return 0


def cmd_start(ns: argparse.Namespace) -> int:
    require_docker()
    workdir, _, container, _, _ = instance_from_workdir(ns, ns.workdir)
    if not container_exists(container):
        raise SystemExit(f"Container not found for workdir: {workdir}\nRun: ./ai-shell up --workdir {workdir}")
    require_managed_container(container, expected_workdir=workdir)
    if container_running(container):
        print(f"OK: '{container}' already running.")
        return 0
    docker(["start", container], capture=True)
    print(f"OK: started '{container}'.")
    return 0


def cmd_stop(ns: argparse.Namespace) -> int:
    require_docker()
    workdir, _, container, _, _ = instance_from_workdir(ns, ns.workdir)
    if not container_exists(container):
        raise SystemExit(f"Container not found for workdir: {workdir}")
    require_managed_container(container, expected_workdir=workdir)
    if not container_running(container):
        print(f"OK: '{container}' already stopped.")
        return 0
    docker(["stop", container], capture=True)
    print(f"OK: stopped '{container}'.")
    return 0


def cmd_status(ns: argparse.Namespace) -> int:
    require_docker()
    workdir, iid, container, image, volume = instance_from_workdir(ns, ns.workdir)
    exists = container_exists(container)
    running = container_running(container) if exists else False
    print(f"workdir:   {workdir}")
    print(f"instance:  {iid}")
    print(f"container: {container} ({'running' if running else 'stopped' if exists else 'missing'})")
    print(f"image:     {image}")
    print(f"volume:    {volume} -> /root")
    if not exists:
        return 0
    require_managed_container(container, expected_workdir=workdir)

    mounts = docker(["inspect", "-f", "{{range .Mounts}}{{println .Type .Source \"->\" .Destination}}{{end}}", container], capture=True).stdout or ""
    mounts = mounts.strip()
    if mounts:
        print("mounts:")
        for line in mounts.splitlines():
            print(f"  {line}")
    return 0


def cmd_enter(ns: argparse.Namespace) -> int:
    require_docker()
    workdir, _, container, _, _ = instance_from_workdir(ns, ns.workdir)
    if not container_exists(container):
        raise SystemExit(f"Container not found for workdir: {workdir}\nRun: ./ai-shell up --workdir {workdir}")
    require_managed_container(container, expected_workdir=workdir)
    if not container_running(container):
        docker(["start", container], capture=True)

    # Ensure ~/.local/bin is on PATH for login shells
    docker(
        [
            "exec",
            container,
            "bash",
            "-lc",
            r'grep -q "\.local/bin" ~/.bashrc 2>/dev/null || echo "export PATH=\"$HOME/.local/bin:$PATH\"" >> ~/.bashrc',
        ],
        check=False,
    )

    if is_tty():
        os.execvp("docker", ["docker", "exec", "-it", container, "bash", "-l"])
    else:
        eprint("Warning: no TTY available; running non-interactive shell.")
        os.execvp("docker", ["docker", "exec", container, "bash", "-l"])


def redact_lines(lines: Iterable[str]) -> list[str]:
    redacted: list[str] = []
    for ln in lines:
        if "TOKEN=" in ln or "KEY=" in ln:
            k = ln.split("=", 1)[0]
            redacted.append(f"{k}=***")
        else:
            redacted.append(ln)
    return redacted


def cmd_check(ns: argparse.Namespace) -> int:
    require_docker()
    workdir, _, container, _, _ = instance_from_workdir(ns, ns.workdir)
    if not container_exists(container):
        raise SystemExit(f"Container not found for workdir: {workdir}\nRun: ./ai-shell up --workdir {workdir}")
    require_managed_container(container, expected_workdir=workdir)
    if not container_running(container):
        raise SystemExit(f"Container is not running: {container} (run: ./ai-shell start --workdir {workdir})")

    # 1) cursor-agent installed?
    p = docker(["exec", container, "bash", "-lc", "command -v cursor-agent && cursor-agent --help | head -30"], check=False, capture=True)
    if p.returncode != 0:
        eprint("ERROR: cursor-agent not found. Re-run: ./ai-shell recreate")
        if p.stdout:
            eprint(p.stdout.rstrip())
        return 2
    print("OK: cursor-agent is installed.")

    # 2) cursor config mount present?
    p2 = docker(["exec", container, "bash", "-lc", "ls -la /root/.config/cursor/ 2>/dev/null | head -50"], check=False, capture=True)
    if p2.returncode != 0:
        eprint("ERROR: /root/.config/cursor is missing. Ensure host Cursor is installed/signed in.")
        return 2
    print("OK: /root/.config/cursor is mounted.")

    # 3) gh auth (optional) - never fail the check
    p3 = docker(["exec", container, "bash", "-lc", "gh auth status 2>&1 | head -50"], check=False, capture=True)
    out = (p3.stdout or "").splitlines()
    out = redact_lines(out)
    if out:
        print("gh auth (optional):")
        for ln in out:
            print(f"  {ln}")
    else:
        print("gh auth (optional): (no output)")

    return 0


def cmd_ls(ns: argparse.Namespace) -> int:
    require_docker()
    p = docker(["ps", "-a", "--filter", f"label={LABEL_MANAGED}=true", "--format", "{{.Names}}"], capture=True)
    names = [ln.strip() for ln in (p.stdout or "").splitlines() if ln.strip()]
    if not names:
        print("No ai-shell managed containers found.")
        return 0

    rows: list[tuple[str, str, str]] = []
    for name in sorted(names):
        info = inspect_container(name)
        labels = ((info.get("Config") or {}).get("Labels") or {})
        wd = labels.get(LABEL_WORKDIR, "")
        st = ((info.get("State") or {}).get("Status") or "unknown")
        rows.append((wd, name, st))

    # Simple aligned output
    wd_w = max(len(r[0]) for r in rows)
    name_w = max(len(r[1]) for r in rows)
    print(f"{'WORKDIR'.ljust(wd_w)}  {'CONTAINER'.ljust(name_w)}  STATUS")
    for wd, name, st in rows:
        print(f"{wd.ljust(wd_w)}  {name.ljust(name_w)}  {st}")
    return 0


def cmd_rm(ns: argparse.Namespace) -> int:
    require_docker()
    workdir, _, container, _, volume = instance_from_workdir(ns, ns.workdir)
    if not container_exists(container):
        print(f"OK: no container for workdir: {workdir}")
        return 0
    require_managed_container(container, expected_workdir=workdir)
    docker(["stop", container], check=False, capture=True)
    docker(["rm", container], check=False, capture=True)
    print(f"OK: removed container '{container}'.")
    if ns.volume:
        docker(["volume", "rm", volume], check=False, capture=True)
        print(f"OK: removed volume '{volume}'.")
    return 0


def build_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(
        prog="ai-shell",
        formatter_class=argparse.RawTextHelpFormatter,
        description=(
            "Manage per-workdir ai-shell Docker containers.\n\n"
            "Workdir is the identity: one container + one /root volume per workdir.\n\n"
            "Defaults can be overridden via env vars:\n"
            "  AI_SHELL_CONTAINER (base name, default: ai-agent-shell)\n"
            "  AI_SHELL_IMAGE     (default: ai-agent-shell)\n"
            "  AI_SHELL_VOLUME    (base name, default: ai_agent_shell_home)\n"
        ),
    )

    # Note: argparse only parses "global" options before the subcommand.
    # To support `ai-shell <cmd> --workdir ...`, we also attach --workdir to each relevant subcommand.
    p.add_argument("--workdir", help="Target workdir (default: current directory)")
    p.add_argument("--container-base", dest="container_base", help="Container base name (overrides AI_SHELL_CONTAINER)")
    p.add_argument("--image", help="Image name (overrides AI_SHELL_IMAGE)")
    p.add_argument("--volume-base", dest="volume_base", help="Volume base name for /root (overrides AI_SHELL_VOLUME)")

    sub = p.add_subparsers(dest="cmd", required=True)

    workdir_parent = argparse.ArgumentParser(add_help=False)
    workdir_parent.add_argument("--workdir", help="Target workdir (default: current directory)")

    sp = sub.add_parser("up", parents=[workdir_parent], help="Create/start the workdir container (optionally build/install)")
    sp.add_argument("--cursor-config", default="~/.config/cursor", help="Host Cursor config directory (default: ~/.config/cursor)")
    sp.add_argument(
        "--env-file",
        default=None,
        help=(
            "Env file to pass to docker run.\n"
            "Default: use ./.env only if it exists.\n"
            "Set to empty string to disable even if .env exists."
        ),
    )
    sp.add_argument("--no-build", dest="build", action="store_false", help="Skip docker build")
    sp.add_argument("--no-install", dest="install", action="store_false", help="Skip installing cursor-agent")
    sp.add_argument("--recreate", action="store_true", help="Stop/remove and recreate the container if it already exists")
    sp.set_defaults(func=cmd_up, build=True, install=True)

    # Back-compat within the CLI: 'recreate' is an alias for 'up --recreate'
    sp = sub.add_parser("recreate", parents=[workdir_parent], help="Alias for: up --recreate")
    sp.add_argument("--cursor-config", default="~/.config/cursor", help="Host Cursor config directory (default: ~/.config/cursor)")
    sp.add_argument(
        "--env-file",
        default=None,
        help=(
            "Env file to pass to docker run.\n"
            "Default: use ./.env only if it exists.\n"
            "Set to empty string to disable even if .env exists."
        ),
    )
    sp.add_argument("--no-build", dest="build", action="store_false", help="Skip docker build")
    sp.add_argument("--no-install", dest="install", action="store_false", help="Skip installing cursor-agent")
    sp.set_defaults(func=cmd_up, recreate=True, build=True, install=True)

    sp = sub.add_parser("start", parents=[workdir_parent], help="Start the container")
    sp.set_defaults(func=cmd_start)

    sp = sub.add_parser("stop", parents=[workdir_parent], help="Stop the container")
    sp.set_defaults(func=cmd_stop)

    sp = sub.add_parser("status", parents=[workdir_parent], help="Show container status and mounts")
    sp.set_defaults(func=cmd_status)

    sp = sub.add_parser("enter", parents=[workdir_parent], help="Enter an interactive shell inside the container")
    sp.set_defaults(func=cmd_enter)

    sp = sub.add_parser("check", parents=[workdir_parent], help="Sanity-check cursor-agent + mounts (and optional gh auth)")
    sp.set_defaults(func=cmd_check)

    sp = sub.add_parser("ls", help="List all ai-shell managed containers")
    sp.set_defaults(func=cmd_ls)

    sp = sub.add_parser("rm", parents=[workdir_parent], help="Remove the workdir container (optionally its /root volume)")
    sp.add_argument("--volume", action="store_true", help="Also remove the associated /root volume")
    sp.set_defaults(func=cmd_rm)

    return p


def main(argv: list[str]) -> int:
    parser = build_parser()
    ns = parser.parse_args(argv)

    # Ensure cwd is repo root for build contexts unless user deliberately runs elsewhere.
    # If invoked from elsewhere, Docker build/run paths would surprise; fail fast.
    if (Path.cwd() / "Dockerfile").exists() is False:
        raise SystemExit("Run this from the repo root (where Dockerfile exists).")

    return int(ns.func(ns))


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
